Issues


BRUSHES_C_1_cw
Need a way to decide what to make default brush precisions.
Maybe make one of each type supported by the compile options.
BRUSHES_C_2_cw
I dont know if there is an analogue to temp_buf_swap to put here. 
There are a number of these in this file.
BRUSHES_C_3_cw
This is a hack for version 1 and 2 of the gbr file.
BRUSHES_C_4_cw
Make some square solid brushes for debugging paint_funcs.
BRUSHES_C_5_cw
A check for data types. Should be done differently.


BRUSH_SELECT_C_1_cw
These routines should be passed tags when color brushes are
introduced -- not just generic data like now. So for now
this will only display gray-scale brushes.


BRUSH_HEADER_C_2_cw
FILE_VERSION changed to 3 for Brushes in gimp16.

DRAWABLE_CMDS_C_1_cw
Here we get the drawable tag and convert it to a plugin
GDrawableType and pass this to the plugin.


GIMAGE_CMDS_C_1_cw
This is a partial hack to get an appropriate GImageType
base_type to pass to the plugin (ie need one of the
extended "RGB,GRAY,...,U16_RGB,U16_GRAY,...,FLOAT_RGB,..)
types to pass to plugin.

GIMAGE_CMDS_C_2_cw
This is "glue" to make an appropriate tag for the
new image from one of the extended GImageTypes from
the plugin. Calls gimage_new_tag instead of 
gimage_new.


LAYER_CMDS_C_1_cw
Here we convert the plugin GDrawableType to a drawable tag to
pass to layer_new_tag.


PAINT_CORE_16_C_1_cw
Commented out the grab pointer for debugging
PAINT_CORE_16_C_2_cw 
I changed the brush mask to a canvas in paint_core_init.
PAINT_CORE_16_C_3_cw
I commented out this canvas_delete because the brush
mask is a true canvas now. 
PAINT_CORE_16_C_4_cw  
This is where the +2 needs to be dekludged to make brushse
of the exact ui-advertised size for debugging in the 
paint_funcs. Also see the brush_mask_get function. I wrote
code for solidify for 16bit/float but have not written
subsample for 16bit/float. So if using 16bit you have
to make sure BRUSH_WITH_BORDER is not defined. 


PIXELAREA_C_1_cw
Not sure what to do with the subsample parameter here. scale_area
does use this value. 
PIXELAREA_C_2_cw
Same as above .. subsample not used.
PIXELAREA_C_3_cw
I fixed a portion width bug. If the width isnt clamped here
it can actually be as large as the whole canvas (when canvas
is flat_buf) even if the desired pixelarea width was originally
set. pixelarea_width() was returning widths bigger than the
original pixelarea width. 
PIXELAREA_C_4_cw
fixed portion height clamp bug (see above).


PLUG_IN_C_1_cw
Once the shadow canvas for drawable is working set up this.
PLUG_IN_C_2_cw
Once the shadow canvas for drawable is working set up this.
PLUG_IN_C_3_cw 
Here the shared memory segment tile to pass
plugins is allocated to size TILE_WIDTH x TILE_HEIGHT x TAG_MAX_BYTES




